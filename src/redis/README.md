# redis

* LRU
 * 近最少使用（Least Recently Used，LRU）
 * [go-lru](https://github.com/golang/groupcache/blob/master/lru/lru.go)
    1. 情况一：当有新数据插入时，LRU 算法会把该数据插入到链表头部，同时把原来链表头部的数据及其之后的数据，都向尾部移动一位。
    2. 情况二：当有数据刚被访问了一次之后，LRU 算法就会把该数据从它在链表中的当前位置，移动到链表头部。同时，把从链表头部到它当前位置的其他数据，都向尾部移动一位。
    3. 情况三：当链表长度无法再容纳更多数据时，若再有新数据插入，LRU 算法就会去除链表尾部的数据，这也相当于将数据从缓存中淘汰掉。
 * Redis 中近似 LRU 算法的实现
   1. redisObject上有一个lock 标记访问时间
   2. 判断当前内存使用情况（访问key的时候）（reids.conf maxmemory)
   3. 随机获取一些key 放到待驱逐的数组中（排序）
   4. 选择被淘汰的键值对并删除 (同步或者异步，根据配置 惰性删除)

* LFU
  * 数据访问的频率来选择被淘汰数据的(最不经常使用算法)
  * [go-lfu](https://github.com/dgrijalva/lfu-go/blob/master/lfu.go)

## redis 高可用
* 主从复制如何实现的？ replice of
* 如何避免数据丢失：可用节点不够的时候，主节点拒绝写入
* 同步写入，异步复制
* 主从如何故障自动切换
## 哨兵(sentinel)
* 故障转移:保证高可用master,slave切换
* 是如何工作的[观察节点]（一一般3个节点最成一个哨兵集群)
监控，通知，选主
1. 哨兵间隔1s，想主从节点ping,如果没有在规定时间内返回响应，认为节点不正常
1. 监控到master挂掉，开始选主过程
3. 当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。
4. 哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点
5. 在哨兵集群中选出一个 leader，让 leader 来执行主从切换。类似raft选举过程

* 主从故障转移是如何完成的
1. 已下线主节点属下的所有「从节点」中，挑选出一个状态良好、数据完整的从节点
我们首先要把网络状态不好的从节点给过滤掉。首先把已经下线的从节点过滤掉，然后把以往网络连接状态不好的从节点也给过滤掉。
2. 所有从节点进行三轮考察：优先级、复制进度、ID 号。
3. 在选举出从节点后，哨兵 leader 向被选中的从节点发送 SLAVEOF no one 命令，让这个从节点解除从节点的身份，将其变为新主节点。

4. 哨兵 leader 向所有从节点（server3和server4）发送 SLAVEOF ，让它们成为新主节点的从节点。
5. 哨兵集群终于完成主从切换的工作，那么新主节点的信息要如何通知给客户端呢？

这主要通过 Redis 的发布者/订阅者机制来实现的。每个哨兵节点提供发布者/订阅者机制，客户端可以从哨兵订阅消息。
6. 继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 SLAVEOF 命令，让它成为新主节点的从节点




