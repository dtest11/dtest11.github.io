---
title: mysql- 索引
date: '2020-02-28T16:37:53.000Z'
tags:
  - mysql
---

# mysql-index

总结一下mysql 索引的相关内容，复盘重新学习下。

## for what

索引是 为了在大量数据中快速查找数据而出现的，

## 索引实现方式

索引的底层实现有各种各样的方式，最常见的有 **哈希表**，**有序数组**，和**搜索树**.

1. 哈系表： 这个无需多说，就是输入之后经过hash 然后得到位置，然后从该位置去寻找数据， 这个肯定会出现冲突，他只适合等值查找的， 不能查找某个范围区间的。
2. 有序数组： 这个可以精确查找，和范围查找都是可以的。但是在数据更新的过程中，必须要循环遍历数组，插入数据的时候，后半部分都要整体的移动，效率是很低的。因此这个方式，只适合数据静态数据，数据不会变动。
3. 搜索树： 我们知道二叉树的数据性质是 left &lt;head &lt;  right ， 而在实际的数据库实现中可能使用的是N叉树。

## Innodb 的索引模型

如下语句：

```sql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

表中 R1~R5 的 \(ID,k\) 值分别为 \(100,1\)、\(200,2\)、\(300,3\)、\(500,5\) 和 \(600,6\)，两棵树的示例示意图如下。 ![Alt text](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png%20)

1. primary key: 为主键索引
2. index（k\) : 普通索引

从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）

## 主键索引和普通索引

1. **查询的区别**

   普通索引查询有 **回表** 的操作，需要查询2次

. 如果语句是 select  _from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树； . 如果语句是 select_  from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

1. **索引维护**

   索引的 **分裂**， **合并**

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

1. **为什么会有主键索引**

1.：索引维护的性能 如果使用自定义的字段做主键，那么可能无法保证有序，那么数据库在索引维护的过程中会有页的分裂和合并这个过程耗费的时间是不必要的 2. ： 存储 如果使用内置的primary key 那么只需要存储一个Int 大小的空间，但是如果是自定义的数据，那么可能是一个string , 也可能是一个varchar 耗费存储空间是不一样的

## 覆盖索引

在下面这个表T ，执行 select \* from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？

```sql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

![1212](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)

现在，我们一起来看看这条 SQL 查询语句的执行流程：

* 在 k 索引树上找到 k=3 的记录，取得 ID = 300；
* 再到 ID 索引树查到 ID=300 对应的 R3；
* 在 k 索引树取下一个值 k=5，取得 ID=500；
* 再回到 ID 索引树查到 ID=500 对应的 R4；
* 在 k 索引树取下一个值 k=6，不满足条件，循环结束

在这个过程中，回到主键索引树搜索的过程，我们称为回表, 由于是 select \* 那么不能不回表， 那么有什么办法不回表呢？ 那么就可以用覆盖索引，简单来讲就是： 将select 结果中需要返回的字段，跟where 中的字段做一个联合索引，那么查询过程在 普通索引中的节点中就可以查询到需要的值了。

## 最左前缀原则

最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

#### 引用

* [https://time.geekbang.org/column/intro/139](https://time.geekbang.org/column/intro/139)

