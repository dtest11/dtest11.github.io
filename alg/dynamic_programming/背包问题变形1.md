### [HJ16 购物单](https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&tqId=21237&rp=1&ru=%2Fexam%2Foj%2Fta&qru=%2Fexam%2Foj%2Fta&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：
主件	附件
电脑	打印机，扫描仪
书柜	图书
书桌	台灯，文具
工作椅	无
如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。
每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。
王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 ~ 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。
满意度是指所购买的每件物品的价格与重要度的乘积的总和，假设设第

```go
package main

import (
	"fmt"
)

func readFuck(m int) []Good {
	var temp = make(map[int]Good)
	for i := 0; i < m; i++ {
		var v, p, q int
		fmt.Scan(&v, &p, &q)
		good := Good{v: v, p: p * v}
		if q == 0 {
			good.isMain = true
			old := temp[i]
			good.child = old.child
			temp[i] = good
		} else {
			old := temp[q-1]
			old.child = append(old.child, good)
			temp[q-1] = old
		}
	}
	var result []Good
	for _, v := range temp {
		result = append(result, v)
		for i := range v.child {
			tmp := v.child[i]
			if tmp.v == 0 {
				continue
			}
			result = append(result, v.child[i])
		}
	}
	return result
}

func main() {
	var N, m int
	if _, err := fmt.Scan(&N, &m); err != nil {
		panic(err)
	}
	goods := readFuck(m)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, N+1)
	}

	for i := 1; i <= m; i++ {
		for j := 1; j <= N; j++ {
			dp[i][j] = dp[i-1][j] // 不买跳过
			d := goods[i-1]
			if !d.isMain { // 附属
				continue
			}
			if j >= d.v {
				dp[i][j] = Max(dp[i][j], dp[i-1][j-d.v]+d.p) // 1.买主件
			}
			if d.child != nil && j >= d.v+d.child[0].v { // 2. 主件+附件A
				dp[i][j] = Max(dp[i][j], dp[i-1][j-d.v-d.child[0].v]+d.p+d.child[0].p)
			}
			if len(d.child) == 2 && j >= d.v+d.child[1].v { // 2. 主件+附件B
				dp[i][j] = Max(dp[i][j], dp[i-1][j-d.v-d.child[1].v]+d.p+d.child[1].p)
			}
			if len(d.child) == 2 && j >= d.v+d.child[0].v+d.child[1].v { //  2. 主件+附件B+附件A
				dp[i][j] = Max(dp[i][j], dp[i-1][j-d.v-d.child[0].v-d.child[1].v]+d.p+d.child[0].p+d.child[1].p)
			}
		}
	}
	fmt.Println(dp[m][N])
}

type Good struct {
	v      int
	p      int
	isMain bool // 标记是否是主件
	child  []Good
}

// Max 获取最大值
func Max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

```