微服务+分布式的产物

关注点：
1. 性能
2. 超时控制
3. 自动延长时间
4. 服务依赖

### 1. mysql()
使用表 来记录 使用的行锁 来排除其余的服务来申请
name counter

select * from lock where name ='xxxx' for update 

### 2. redis
SET key value [EX seconds] [PX milliseconds] [NX|XX]

1. 防止超时 添加uuid 标记服务
2. 添加守护线程自动续费时间
3. redis 依赖系统时间，时间回拨
4. 主从复制 复制延迟导致的锁 被重复申请

redlock

解决方案是不采用主从复制，使用RedLock算法（官方推荐）

1. 获取当前Unix时间，以毫秒为单位

2. 依次尝试从N个实例，使用相同的key和随机值获取锁。当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例

3. 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功

4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）

5. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。

GC 停止时间
添加一个逻辑时钟，来解决，抛弃历史时钟的提交
[https://github.com/go-redsync/redsync](https://github.com/go-redsync/redsync)

### 3 etcd

etcd 使用了raft 来保证数据最终一致性
每次key 有version的概念，可以通过写入并检查version的版本，来检查是否获得lock
并通过租约的概念来续费

[https://etcd.io/docs/v3.5/learning/why/](https://etcd.io/docs/v3.5/learning/why/)


[https://medium.com/@felipedutratine/distributed-lock-with-etcd-in-go-d21e7df145bc](https://medium.com/@felipedutratine/distributed-lock-with-etcd-in-go-d21e7df145bc)